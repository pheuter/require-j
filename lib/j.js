// Generated by CoffeeScript 1.5.0
var nodeRequire, _ref;

nodeRequire = require.nodeRequire;

if (typeof global !== "undefined" && global !== null) {
  if ((_ref = global.window) == null) {
    global.window = {};
  }
}

define(function(require) {
  var buildMap, compile, fetchText, fs, getXhr, j, jade, progIds, runtime, _ref1, _ref2;
  jade = require('jade');
  compile = jade.compile;
  runtime = require('runtime');
  progIds = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"];
  fetchText = function() {
    throw new Error("Environment unsupported.");
  };
  if ((typeof process !== "undefined" && process !== null ? (_ref1 = process.versions) != null ? _ref1.node : void 0 : void 0) != null) {
    fs = nodeRequire('fs');
    fetchText = function(path, callback) {
      return callback(fs.readFileSync(path, "utf8"));
    };
  } else if ((((typeof window !== "undefined" && window !== null ? window.navigator : void 0) != null) && ((typeof window !== "undefined" && window !== null ? window.document : void 0) != null)) || (typeof importScripts !== "undefined" && importScripts !== null)) {
    getXhr = function() {
      var i, progId, xhr;
      if (typeof XMLHttpRequest !== "undefined" && XMLHttpRequest !== null) {
        return new XMLHttpRequest();
      } else {
        i = 0;
        while (i < 3) {
          progId = progIds[i];
          try {
            xhr = new ActiveXObject(progId);
          } catch (_error) {}
          if (xhr) {
            progIds = [progId];
            break;
          }
          i += 1;
        }
      }
      if (!xhr) {
        throw new Error("getXhr(): XMLHttpRequest not available");
      }
      return xhr;
    };
    fetchText = function(url, callback) {
      var xhr;
      xhr = getXhr();
      xhr.open("GET", url, true);
      xhr.onreadystatechange = function(evt) {
        if (xhr.readyState === 4) {
          return callback(xhr.responseText);
        }
      };
      return xhr.send(null);
    };
  } else if (typeof Packages !== "undefined" && Packages !== null) {
    fetchText = function(path, callback) {
      var content, encoding, file, input, line, lineSeparator, stringBuffer;
      stringBuffer = void 0;
      line = void 0;
      encoding = "utf-8";
      file = new java.io.File(path);
      lineSeparator = java.lang.System.getProperty("line.separator");
      input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding));
      content = "";
      try {
        stringBuffer = new java.lang.StringBuffer();
        line = input.readLine();
        if (line && line.length() && line.charAt(0) === 0xfeff) {
          line = line.substring(1);
        }
        stringBuffer.append(line);
        while ((line = input.readLine()) !== null) {
          stringBuffer.append(lineSeparator);
          stringBuffer.append(line);
        }
        content = String(stringBuffer.toString());
      } finally {
        input.close();
      }
      return callback(content);
    };
  }
  if ((typeof process !== "undefined" && process !== null ? (_ref2 = process.versions) != null ? _ref2.node : void 0 : void 0) != null) {
    jade.Parser.prototype.parseInclude = function() {
      var baseUrl, path,
        _this = this;
      baseUrl = require.toUrl('.');
      path = this.expect("include").val.trim();
      if (path.indexOf(".") === -1) {
        path += ".jade";
      }
      return fetchText(baseUrl + path, function(str) {
        var ast, parser;
        parser = new jade.Parser(str, path, _this.options);
        parser.blocks = jade.utils.merge({}, _this.blocks);
        parser.mixins = _this.mixins;
        _this.context(parser);
        ast = parser.parse();
        _this.context();
        ast.filename = path;
        if ("indent" === _this.peek().type) {
          ast.includeBlock().push(_this.block());
        }
        return ast;
      });
    };
    jade.Parser.prototype.parseExtends = function() {
      var baseUrl, path,
        _this = this;
      baseUrl = require.toUrl('.');
      path = this.expect("extends").val.trim();
      if (path.indexOf(".") === -1) {
        path += ".jade";
      }
      return fetchText(baseUrl + path, function(str) {
        var parser;
        parser = new jade.Parser(str, path, _this.options);
        parser.blocks = _this.blocks;
        parser.contexts = _this.contexts;
        _this.extending = parser;
        return new jade.nodes.Literal("");
      });
    };
  }
  buildMap = {};
  j = {
    version: '0.0.1',
    load: function(name, parentRequire, onload, config) {
      var path;
      path = parentRequire.toUrl(name + '.jade');
      return fetchText(path, function(text) {
        var func;
        func = compile(text, {
          client: true
        });
        if (config.isBuild) {
          buildMap[name] = func;
        }
        return onload();
      });
    },
    write: function(pluginName, moduleName, write) {
      var func;
      if (moduleName in buildMap) {
        func = buildMap[moduleName];
        return write.asModule(pluginName + "!" + moduleName, "define(function() {\n  return " + func + ";\n});");
      }
    }
  };
  return j;
});
